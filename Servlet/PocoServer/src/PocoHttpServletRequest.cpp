//
// PocoHttpServletRequest.cpp
//
// Library: PocoServer
// Package: PocoServerCore
// Module:  PocoHttpServletRequest
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Servlet/PocoServer/PocoHttpServletRequest.h"
#include "Poco/Servlet/Ex/HttpServletDispatcher.h"
#include "Poco/Servlet/Ex/HttpRequestDispatcher.h"
#include "Poco/Net/HTTPServerRequest.h"
#include "Poco/Net/HTMLForm.h"
#include "Poco/Net/HTTPRequest.h"
#include "Poco/DateTimeParser.h"
#include "Poco/DateTime.h"
#include "Poco/NumberParser.h"
#include "Poco/URI.h"
#include "Poco/Path.h"
#include "Poco/File.h"
#include <sstream>


using Poco::Net::HTTPServerRequest;
using Poco::Net::NameValueCollection;
using Poco::Net::HTMLForm;
using Poco::Net::HTTPRequest;
using Poco::Servlet::Ex::HttpServletDispatcher;
using Poco::Servlet::Ex::HttpRequestDispatcher;


namespace Poco {
namespace Servlet {
namespace PocoServer {


PocoHttpServletRequest::PocoHttpServletRequest(HTTPServerRequest& request, 
	HttpServletDispatcher* pDispatcher,
	const std::string rootPath):
	_request(request), 
	_istream(request.stream()), 
	_reader(_istream),
	_pSession(0), 
	_pSessionManager(0), 
	_pServletDispatcher(pDispatcher), 
	_rootPath(rootPath)
{
	_locales.push_back(std::locale::classic());
	assignParameters();
}


PocoHttpServletRequest::~PocoHttpServletRequest()
{
	RequestDispatherVec::iterator it = _reqDispatcherVec.begin();

	for(; it != _reqDispatcherVec.end(); ++it)
		delete *it;
}


void PocoHttpServletRequest::assignParameters()
{
	HTMLForm form(_request, _request.stream());

	NameValueCollection::ConstIterator it = form.begin();
	for(; it != form.end(); ++it)
	{
		_parameters.insert(make_pair(it->first, it->second));
	}
}


const Object* PocoHttpServletRequest::getAttribute(const std::string& name) const 
{ 
	AttributeMap::const_iterator it = _attributes.find(name);
	if(it != _attributes.end()) return it->second;
	else return 0;
}


std::vector<std::string> PocoHttpServletRequest::getAttributeNames() const 
{ 
	std::vector<std::string> s;
	AttributeMap::const_iterator it = _attributes.begin();
	for(; it != _attributes.end(); ++it)
		s.push_back(it->first);

	return s;
}


std::string PocoHttpServletRequest::getCharacterEncoding() const 
{ 
	return _characterEncoding;
}


int PocoHttpServletRequest::getContentLength() const 
{ 
	return _request.getContentLength();
}


std::string PocoHttpServletRequest::getContentType() const 
{ 
	return _request.getContentType();
}


ServletInputStream& PocoHttpServletRequest::getInputStream() 
{ 
	return _istream;
}


std::string PocoHttpServletRequest::getLocalAddr() const 
{ 
	return _request.serverAddress().toString();
}


std::locale PocoHttpServletRequest::getLocale() const 
{ 
	return _locales[0];
}


const std::vector<std::locale>& PocoHttpServletRequest::getLocales() const 
{ 
	return _locales;
}


std::string PocoHttpServletRequest::getLocalName() const 
{ 
	return _request.serverAddress().host().toString();
}


int PocoHttpServletRequest::getLocalPort() const 
{ 
	return _request.serverAddress().port();
}


std::string PocoHttpServletRequest::getParameter(const std::string& name) const 
{
	std::string parameter = "";

	ParameterMap::const_iterator it = _parameters.find(name);

	if(it != _parameters.end())
		parameter = it->second;

	return parameter;
}


ServletRequest::ParameterMap PocoHttpServletRequest::getParameterMap() const 
{ 
	return _parameters;
}


std::vector<std::string> PocoHttpServletRequest::getParameterNames() const 
{ 
	std::vector<std::string> pm;

	ParameterMap::const_iterator it = _parameters.begin();

	for(; it != _parameters.end(); ++it)
		pm.push_back(it->first);

	return pm;
}


std::vector<std::string> PocoHttpServletRequest::getParameterValues(const std::string& name) const 

{ 
	std::vector<std::string> pm;

	ParameterMap::const_iterator it = _parameters.begin();

	for(; it != _parameters.end(); ++it)
		pm.push_back(it->second);

	return pm;
}


std::string PocoHttpServletRequest::getProtocol() const 
{ 
	return _request.getVersion();
}


BufferedReader& PocoHttpServletRequest::getReader()
{ 
	return _reader;
}


std::string PocoHttpServletRequest::getRemoteAddr() const 
{ 
	return _request.clientAddress().toString();
}


std::string PocoHttpServletRequest::getRemoteHost() const 
{ 
	return _request.clientAddress().host().toString();
}


int PocoHttpServletRequest::getRemotePort() const 
{ 
	return _request.clientAddress().port();
}


RequestDispatcher& PocoHttpServletRequest::getRequestDispatcher(const std::string& path) 
{ 
	poco_check_ptr(_pServletDispatcher);

	RequestDispatherVec::iterator it = _reqDispatcherVec.begin();
	for(; it != _reqDispatcherVec.end(); ++it)
	{
		if ((*it)->path() == path)
			return **it;
	}

	_reqDispatcherVec.push_back(new HttpRequestDispatcher(*_pServletDispatcher, path));
	return *_reqDispatcherVec.back();
}


std::string PocoHttpServletRequest::getScheme() const 
{ 
	Poco::URI uri(_request.getURI());
	return uri.toString();
}


std::string PocoHttpServletRequest::getServerName() const 
{ 
	std::string name(_request.getHost());

	if("" == name)
		name = _request.serverAddress().host().toString();

	std::string::size_type pos;
	if((pos = name.find(':')) != name.npos)
		name = name.substr(0, pos);

	return name;
}


int PocoHttpServletRequest::getServerPort() const 
{ 
	return _request.serverAddress().port();
}


bool PocoHttpServletRequest::isSecure() const 
{ 
	return "https" == getScheme();
}


void PocoHttpServletRequest::removeAttribute(const std::string& name) 
{ 
	_request.erase(name);
}


void PocoHttpServletRequest::setAttribute(const std::string& name, Object* a) 
{ 
	if(0 != a)	_attributes.insert(std::make_pair(name, a));
	else		removeAttribute(name);
}


void PocoHttpServletRequest::setCharacterEncoding(const std::string& enc) 
{ 
	_characterEncoding = enc;
}


const std::vector<Cookie>& PocoHttpServletRequest::getCookies() const
{
	if(_cookies.empty())
	{
		NameValueCollection cookies;
		_request.getCookies(cookies);

		NameValueCollection::ConstIterator it = cookies.begin();
		for(; it != cookies.end(); ++it)
		{
			Cookie c(it->first, it->second);
			_cookies.push_back(c);
		}
	}

	return _cookies;
}


long PocoHttpServletRequest::getDateHeader(const std::string& name) 
{ 
	int tzd; 
	DateTime dt;

	if(DateTimeParser::tryParse(_request.get(name), dt, tzd))
		return dt.timestamp().epochTime();

	return -1L;
}


std::string PocoHttpServletRequest::getHeader(const std::string& name) 
{
	std::string ret;

	try
	{
		ret = _request.get(name);
	}
	catch(NotFoundException&)
	{
		return "";
	}

	return ret;
}


std::vector<std::string> PocoHttpServletRequest::getHeaders(const std::string& name) 
{ 
  std::vector<std::string> str;

	NameValueCollection::ConstIterator it = _request.begin();
	for(; it != _request.end(); ++it)
	{
		if(it->first == name)
			str.push_back(it->second);
	}

	return str;
} 


std::vector<std::string> PocoHttpServletRequest::getHeaderNames() 
{ 
  std::vector<std::string> str;

	NameValueCollection::ConstIterator it = _request.begin();
	for(; it != _request.end(); ++it)
			str.push_back(it->first);

	return str;
}


int PocoHttpServletRequest::getIntHeader(const std::string& name) 
{ 
	int i=-1;

	std::string hdr = getHeader(name);

	if("" != hdr)
	{
		try
		{
			i = NumberParser::parse(hdr);
		}
		catch(SyntaxException& ex)
		{
			throw DataFormatException(ex.displayText());
		}
	}

	return i;
}


std::string PocoHttpServletRequest::getPathInfo() 
{ 
	try
	{
		URI uri(_request.getURI());
		return(uri.getPath());
	}
	catch(SyntaxException&)
	{
		throw;
	}
}


std::string PocoHttpServletRequest::getPathTranslated() const
{ 
	std::string reqURI = _request.getURI();
	std::string fullPath(_rootPath + reqURI);

	if (File(fullPath).exists()) return fullPath;

	return reqURI;
}


std::string PocoHttpServletRequest::getContextPath() const
{ 
	std::string uri = _request.getURI();
	char delim = '/';
	std::string::size_type begin = uri.find_first_of(delim);
	std::string::size_type length = uri.find_first_of(delim, uri.find_first_not_of(delim));
  
	return uri.substr(begin, length);
}


std::string PocoHttpServletRequest::getQueryString() 
{ 
	try
	{
		URI uri(_request.getURI());
		return(uri.getQuery());
	}
	catch(SyntaxException&)
	{
		throw;
	}
}


std::string PocoHttpServletRequest::getRemoteUser() 
{ 
 //TODO
  return "";
}


bool PocoHttpServletRequest::isUserInRole(const std::string& role) 
{ 
  //TODO
  return false;
}


std::string PocoHttpServletRequest::getRequestedSessionId() const
{ 
  if(isRequestedSessionIdFromCookie())
	{
		const std::vector<Cookie>& cookies = getCookies();
		std::vector<Cookie>::const_iterator it = cookies.begin();
		for(; it != cookies.end(); ++it)
		{
			if(HttpSession::COOKIE_SESSION_ID == it->getName())	
				return it->getValue();
		}
	}
	else if(isRequestedSessionIdFromURL())
	{
		return getParameter(HttpSession::URI_SESSION_ID);
	}

  return "";
}


std::string PocoHttpServletRequest::getRequestURI() 
{ 
	URI uri(_request.getURI());
	return(uri.toString());
}


std::string PocoHttpServletRequest::getRequestURL() 
{ 
	try
	{
		URI uri(_request.getURI());
		std::stringstream ss;
		
		ss << uri.getScheme() << "://" << uri.getHost();
		
		if((("http" == uri.getScheme()) && (80 != uri.getPort())) ||
			((("https" == uri.getScheme()) && (443 != uri.getPort()))))
		{
			ss	<< ':' << uri.getPort();
		}

		ss << uri.getPath();

		return(ss.str());
	}
	catch(SyntaxException&)
	{
		throw;
	}
}


std::string PocoHttpServletRequest::getServletPath() 
{ 
	URI uri(_request.getURI());
	return uri.getPath();
}


void PocoHttpServletRequest::setServletPath(const std::string& path) 
{ 
	_request.setURI(path);
}


const HttpSession* PocoHttpServletRequest::getSession(bool create)
{ 
	if(!_pSession)
	{
		std::string sessionId = getRequestedSessionId();

		if(("" != sessionId) && isRequestedSessionIdValid())
			_pSession = &_pSessionManager->session(sessionId);
		else if(create)			
			_pSession = &_pSessionManager->makeSession();
	}

	return _pSession;
}


const HttpSession* PocoHttpServletRequest::getSession()
{ 
	if(!_pSession) _pSession = getSession(true);

	return _pSession;
}


bool PocoHttpServletRequest::isRequestedSessionIdValid() const
{ 
	bool valid = false;
	poco_check_ptr(_pSessionManager);

	return _pSessionManager->isValid(getRequestedSessionId());
}


bool PocoHttpServletRequest::isRequestedSessionIdFromCookie() const
{ 
	const std::vector<Cookie>& cookies = getCookies();
	std::vector<Cookie>::const_iterator it = cookies.begin();
	for(; it != cookies.end(); ++it)
		if(HttpSession::COOKIE_SESSION_ID == it->getName())	return true;

	return false;
}


bool PocoHttpServletRequest::isRequestedSessionIdFromURL() const
{ 
	return (!isRequestedSessionIdFromCookie() &&
					getParameter(HttpSession::URI_SESSION_ID) != "");
}


bool PocoHttpServletRequest::isRequestedSessionIdFromUrl() const
{ 
	return isRequestedSessionIdFromURL();
}


} } } // namespace Poco::Servlet::PocoServer
