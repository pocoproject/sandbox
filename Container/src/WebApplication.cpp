//
// WebApplicationImpl.cpp
//
// Library: Container
// Package: ContainerCore
// Module:  WebApplicationImpl
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Servlet/Container/ServletContextImpl.h"
#include "Poco/Servlet/Container/ConfigImpl.h"
#include "Poco/Servlet/Container/ContainedFactory.h"
#include "Poco/Servlet/Container/SessionManagerImpl.h"
#include "Poco/Servlet/Filter.h"
#include "Poco/Servlet/HttpServletRequest.h"
#include "Poco/Servlet/HttpServletResponse.h"
#include "Poco/Servlet/Container/HttpSessionImpl.h"
#include "Poco/Servlet/Container/WebApplication.h"
#include "Poco/Servlet/Container/Contained.h"
#include "Poco/Servlet/Container/FilterChainImpl.h"
#include "Poco/Servlet/Ex/HttpServletDispatcher.h"
#include "Poco/Servlet/Ex/PathMapping.h"
#include "Poco/Logger.h"
#include "Poco/PatternFormatter.h"
#include "Poco/FormattingChannel.h"
#include "Poco/SplitterChannel.h"
#include "Poco/ConsoleChannel.h"
#include "Poco/FileChannel.h"
#include "Poco/Message.h"
#include "Poco/DirectoryIterator.h"
#include "Poco/Path.h"
#include "Poco/String.h"
#include "Poco/AutoPtr.h"
#include "Poco/SharedLibrary.h"
#include "Poco/ClassLoader.h"
#include "Poco/Exception.h"
#include "Poco/NumberParser.h"
#include "Poco/Observer.h"
#include <fstream>
#include <utility>


using Poco::Servlet::Ex::FilterDispatcher;
using Poco::Servlet::Ex::HttpServletDispatcher;
using Poco::Servlet::Ex::ServletProvider;


namespace Poco {
namespace Servlet {
namespace Container {


/// HttpSessionListenerImpl

HttpSessionListenerImpl::HttpSessionListenerImpl(WebApplication* pApp):
_pApp(pApp)
{
}


void HttpSessionListenerImpl::sessionCreated(const HttpSessionEvent& se)
{
}


void HttpSessionListenerImpl::sessionDestroyed(const HttpSessionEvent& se)
{
	std::vector<std::string> servlets;
	const HttpSession* psession = se.getSession();
	poco_check_ptr(psession);
	_pApp->getServletNames(psession->getId(), servlets);

	std::vector<std::string>::iterator it = servlets.begin();
	for(; it != servlets.end(); ++it)
	{
		WebApplication::ServletMap::iterator mit = _pApp->_servletMap.find(*it);
		if(_pApp->_servletMap.end() != mit)	_pApp->deleteServlet(mit->second, "Session timeout");
	}
}


/// HttpServletProviderImpl

HttpServletProviderImpl::HttpServletProviderImpl(WebApplication* pApp):
HttpServletProvider(pApp->name()), _pApp(pApp)
{
}


HttpServlet* HttpServletProviderImpl::getHttpServlet(const std::string& servletName) const
{
	HttpServlet* ps = 0;
	WebApplication::ServletMap::iterator it = _pApp->_servletMap.find(servletName);

	if(_pApp->_servletMap.end() != it) 
	{
		ps = it->second->instance();
	}
	else 
	{
		std::string className(servletName);
		className = className.substr(0, className.find(ServletProvider::NAME_SEPARATOR, 0));
		if(_pApp->isServletClassRegistered(className))
		{
			ps = const_cast<HttpServlet*>(_pApp->createServlet(className, servletName));
		}
	}

	return ps;
}


/// FilterProviderImpl

FilterProviderImpl::FilterProviderImpl(WebApplication* pApp):
FilterProvider(pApp->name()), _pApp(pApp)
{
}


const Filter& FilterProviderImpl::getFilter(const std::string& filterName) const
{
	Filter* pf = 0;
	WebApplication::FilterMap::iterator it = _pApp->_filterMap.find(filterName);

	if(_pApp->_filterMap.end() != it) 
	{
		pf = it->second->instance();
	}
	else 
	{
		if(_pApp->isFilterClassRegistered(filterName))
		{
			pf = const_cast<Filter*>(_pApp->createFilter(filterName, filterName));
		}
	}

	if(!pf) pf = &_filter;
	return *pf;
}


const FilterChain& FilterProviderImpl::getFilterChain(const Servlet& servlet)
{
	std::string servletName = 
		_pApp->getServletBaseName(servlet.getServletConfig().getServletName());

	ServletContextImpl::FilterServletMapping mapping = 
		_pApp->_pContext->getFilterServletMapping();

	FilterChainImpl* pfc = 0;
	ServletContextImpl::FilterServletMapping::iterator itfsm;
	for(itfsm = mapping.begin(); itfsm != mapping.end(); ++itfsm)
	{
		if(itfsm->second == servletName)
		{
			FilterChainMap::iterator itfcm = _chainMap.find(servletName);
			if(itfcm == _chainMap.end())
			{
				pfc = new FilterChainImpl(&getFilter(itfsm->first));
				poco_check_ptr(pfc);
				_chainMap.insert(FilterChainMap::value_type(servletName, pfc));
			}
			else pfc = const_cast<FilterChainImpl*>(itfcm->second);

			poco_check_ptr(pfc);
			pfc->appendFilter(&getFilter(itfsm->first));
		}
	}

	if(!pfc) //"filterless" chain - has only servlet resource
	{
		FilterChainMap::iterator itfcm = _chainMap.find(servletName);
		if(itfcm == _chainMap.end())
		{
			pfc = new FilterChainImpl(&servlet);
			poco_check_ptr(pfc);
			_chainMap.insert(FilterChainMap::value_type(servletName, pfc));
		}
		else pfc = const_cast<FilterChainImpl*>(itfcm->second);
	}
	
	poco_check_ptr(pfc);
	pfc->setServlet(&servlet);

	return *pfc;
}


FilterProviderImpl::~FilterProviderImpl()
{
	FilterChainMap::iterator it = _chainMap.begin();
	for(; it != _chainMap.end(); ++it)
		delete it->second;

	_chainMap.erase(_chainMap.begin(), _chainMap.end());
}


/// WebApplication

FastMutex WebApplication::_mutex;

WebApplication::WebApplication(const std::string& base,
	HttpServletDispatcher& servletDispatcher,
	FilterDispatcher* pFilterDispatcher): 
	Contained(base), 
	_pContext(0), 
	_pSessionManager(0), 
	_servletDispatcher(servletDispatcher), 
	_pFilterDispatcher(pFilterDispatcher),
	_sessionListener(this), 
	_servletProvider(this), 
	_filterProvider(this)
{
	init();
}


WebApplication::~WebApplication()
{
	delete _pSessionManager;

	//delete all loaded servlets and filter structs
	//(along with any servlets/filters we are responsible for)
	while(_servletMap.size())
		deleteServlet(_servletMap.begin()->second, "Application destroyed");

	while(_filterMap.size())
		deleteFilter(_filterMap.begin()->second, "Application destroyed");


	//delete all registered servlets structs
	ServletRegMap::iterator rit = _regServletMap.begin();
	for(; rit != _regServletMap.end(); ++rit)
		delete rit->second;

	delete _pContext;

	//unload all shared libraries
	while(_servletLoader.begin() != _servletLoader.end())
		_servletLoader.unloadLibrary(_servletLoader.begin()->first);

	while(_filterLoader.begin() != _filterLoader.end())
		_filterLoader.unloadLibrary(_filterLoader.begin()->first);
}


void WebApplication::deleteServlet(HttpServletInfo* psi, const std::string& reason)
{
	std::string name("");

	if(psi)
	{
		name = psi->name();
		if(psi->instance())
		{
			try
			{
				std::string className = psi->regInfo().className();
				// notify the servlet that it is being destroyed
				psi->instance()->destroy();

				// only delete servlet if container owns it
				//(autoDelete servlets are taken care of by the class loader)
				if(!_servletLoader.isAutoDelete(className, psi->instance()))
				{
					delete psi->instance();
				}
				else
				{
					_servletLoader.destroy(psi->regInfo().className(), psi->instance());
				}

				std::ostringstream os;
				os << "Destroyed: " << name; 
				if("" != reason) os << "; Reason: " << reason;
				if(_pLogger) _pLogger->information(os.str());
			}
			catch(ServletException& ex)
			{
				if(_pLogger) _pLogger->warning(ex.getRootCause());
			}
			catch(NotFoundException& ex)
			{
				if(_pLogger) _pLogger->error(std::string(ex.name()) + ": " + ex.message());
			}
		}
  
	  //delete EntityInfo structure
	  delete psi;
	}

  _servletMap.erase(_servletMap.find(name));
}


void WebApplication::deleteFilter(FilterInfo* psi, const std::string& reason)
{
	std::string name("");

	if(psi)
	{
		name = psi->name();
		if(psi->instance())
		{
			try
			{
				std::string className = psi->regInfo().className();
				// notify the servlet that it is being destroyed
				psi->instance()->destroy();

				// only delete servlet if container owns it
				//(autoDelete servlets are taken care of by the class loader)
				if(!_filterLoader.isAutoDelete(className, psi->instance()))
				{
					delete psi->instance();
				}
				else
				{
					_filterLoader.destroy(psi->regInfo().className(), psi->instance());
				}

				std::ostringstream os;
				os << "Destroyed servlet: " << name; 
				if("" != reason) os << "; Reason: " << reason;
				if(_pLogger) _pLogger->information(os.str());
			}
			catch(ServletException& ex)
			{
				if(_pLogger) _pLogger->warning(ex.getRootCause());
			}
			catch(NotFoundException& ex)
			{
				if(_pLogger) _pLogger->error(std::string(ex.name()) + ": " + ex.message());
			}
		}
  
	  //delete EntityInfo structure
	  delete psi;
	}

  _filterMap.erase(_filterMap.find(name));
}


void WebApplication::init()
{
	createContext();
	initLogging();
	setInitParameters();
	initServlets();
	initFilters();
	setupDispatchers();
}


void WebApplication::createContext()
{
	if(_pContext)
	{
		std::string name(_pContext->getName());
		if(_servletDispatcher.isRegistered(name))
			_servletDispatcher.unregisterContext(name);

		if(_pFilterDispatcher)
		{
			if(_pFilterDispatcher->isRegistered(name))
				_pFilterDispatcher->unregisterContext(name);
		}
	}

	delete _pContext;
	_pContext = new ServletContextImpl(_rootPath.toString(), _servletDispatcher, _pLogger);
	_pContext->setInitParameters(*_pConf);
	_pContext->setMimeMap(_servletDispatcher.getMimeMap());
}


void WebApplication::setupDispatchers()
{
	poco_check_ptr(_pContext);
	std::string name(_pContext->getName());
	_servletDispatcher.registerContext(name, _pContext);
	_servletDispatcher.addMapping(name, _pContext->getServletPathMapping());
	if(_pFilterDispatcher)
	{
		_pFilterDispatcher->registerContext(name, _pContext);
		_pFilterDispatcher->addMapping(name, _pContext->getFilterPathMapping());
	}

	poco_check_ptr(_pSessionManager);
	_servletDispatcher.setSessionManager(_pSessionManager);
	_servletDispatcher.addServletProvider(&_servletProvider);
	if(_pFilterDispatcher)
		_pFilterDispatcher->addFilterProvider(&_filterProvider);
}


void WebApplication::setInitParameters()
{
	//-1 means no timeout
	std::string tout = _pConf->getString("session-config.session-timeout", "-1");
	std::string maxno = _pConf->getString("session-config.max-session-count", "512");

	if(_pLogger) 
	{
		_pLogger->information("session-timeout=" + tout);
		_pLogger->information("max-session-count=" + maxno);
	}
	
	delete _pSessionManager;
	_pSessionManager = new SessionManagerImpl(NumberParser::parse(tout)*60, &_sessionListener, NumberParser::parse(maxno));
	
	if(_pContext) _pContext->setInitParameter("session-config.session-timeout", tout);
}


bool WebApplication::extractEntities(ConfigImpl& config, const std::string& entityName, int pos)
{
	std::string value;
	std::string className;
	std::string libName;
	std::ostringstream ss;

	ss.str("");
	ss << entityName << "[" << pos << "]." << entityName << "-name";
	value = _pConf->getString(ss.str(), "");
	if("" == value) return false;

	if(_pLogger) _pLogger->information("");
	ss.str("");	ss << "Found " << entityName << ":" << value;
	if(_pLogger) _pLogger->information(ss.str());
	config.setName(value);

	ss.str("");	ss << entityName << "[" << pos << "]." << entityName << "-class";
	className = _pConf->getString(ss.str(), "");
	if(_pLogger) _pLogger->information("Class: " + className);
	config.setClass(className);

	ss.str("");	ss << entityName << "[" << pos << "]." << entityName << "-lib";
	libName = _pConf->getString(ss.str(), "");
	if(_pLogger) _pLogger->information("Shared library: " + libName);
	config.setLibrary(libName);

	ss.str("");	ss << entityName << "[" << pos << "].description";
	value = _pConf->getString(ss.str(), "");
	if(_pLogger) _pLogger->information("Description: " + value);
	config.setDisplayName(value);

	ss.str("");	ss << entityName << "[" << pos << "].display-name";
	value = _pConf->getString(ss.str(), "");
	if(_pLogger) _pLogger->information("Display name: " + value);
	config.setDisplayName(value);

	//set parameters
	int cntpar = 0;
	std::string name = "";
	value = "";

	do
	{
		ss.str("");
		ss << entityName << "[" << pos << "].init-param.param-name[" << cntpar << "]";
		name = _pConf->getString(ss.str(), "");
		if("" == name)
			break;
		
		ss.str("");
		ss << entityName << "[" << pos << "].init-param.param-value[" << cntpar << "]";
		value = _pConf->getString(ss.str(), "");
		
		if(_pLogger)
		{
			ss.str("");
			ss << "Init parameter: " << name << '=' << value;
			_pLogger->information(ss.str());
		}

		config.setInitParameter(name, value);

		++cntpar;
		name = value = "";
	}while(true);

	return true;
}


void WebApplication::initFilters()
{
	int cnt = 0;

	do
	{
		FilterConfigImpl* pFConfig = new FilterConfigImpl(*_pContext);
		if (!extractEntities(*pFConfig, "filter", cnt)) break;
		FilterRegInfo* psri = new FilterRegInfo(pFConfig);
		_regFilterMap.insert(make_pair(psri->className(), psri));
		++cnt;
	}while(true);
}


void WebApplication::initServlets()
{
	int cnt = 0;
	std::map<int, ServletRegInfo*> preLoadServlets;

	do
	{
		std::ostringstream ss("");
		ServletConfigImpl* pSConfig = new ServletConfigImpl(*_pContext);
		if (!extractEntities(*pSConfig, "servlet", cnt)) break;
		ServletRegInfo* psri = new ServletRegInfo(pSConfig);
		_regServletMap.insert(make_pair(psri->className(), psri));

		//Assign default mappings for each discovered servlet.
		// (additional mappings are assigned by the context).
		std::string servlet = pSConfig->getServletName();
		std::string path = "/";	path += servlet;
		_pContext->assignServletMapping(path, servlet);
		ss << "Path " << path << " mapped to " << servlet;
		if(_pLogger) _pLogger->information(ss.str());

		ss.str("");
		ss << "servlet[" << cnt << "].load-on-startup";
		//negative load-on-startup value means container is 
		//free to load the servlet whenever it wants/needs
		int loadOnStartup = NumberParser::parse(_pConf->getString(ss.str(), "-1"));
		//load order is respected, based on load-on-startup value, so
		//if servlet is to be loaded at this time, it is first inserted into this map
		if(loadOnStartup >= 0)
			preLoadServlets.insert(std::make_pair(loadOnStartup, psri));

		++cnt;
	}while(true);

	//load pre-load servlets in order
	std::map<int, ServletRegInfo*>::iterator sit = preLoadServlets.begin();
	if (sit != preLoadServlets.end()) 
	{
		if(!_servletLoader.isLibraryLoaded(getSharedLibPath(sit->second->libName()).toString()))
			poco_assert(loadServletSharedLib(sit->second->libName()));
	}

	for(;sit != preLoadServlets.end(); sit++)
	{
		std::string cls = sit->second->className();
		createServlet(cls, cls);
	}
}


ServletContext& WebApplication::getContext()
{
	poco_check_ptr(_pContext);
	return *_pContext;
}


const HttpServlet* WebApplication::getServlet(const std::string& servletName) const
{
	ServletMap::const_iterator srit = _servletMap.find(servletName);

	if(_servletMap.end() == srit) return 0;
	
	return srit->second->instance();
}


const HttpServlet* WebApplication::createServlet(const std::string& className, 
	const std::string& servletName)
{
	HttpServlet* ps = 0;
	std::string servletName_ = servletName;
  if("" == servletName_) servletName_ = className;

	ServletRegMap::iterator srit = _regServletMap.find(className);

	if(_regServletMap.end() == srit) // unknown servlet class requested
	{
		std::stringstream ss("");
		ss << "Could not load servlet of class [" << className << "]";
		if(_pLogger) _pLogger->error(ss.str());
		throw NotFoundException(ss.str());
	}
	else
	{
		std::stringstream ss("");

		FastMutex::ScopedLock lock(_mutex);

		ServletMap::iterator sit = _servletMap.find(servletName_);

		if(_servletMap.end() != sit) // servlet already loaded
		{
			ss << "Servlet already loaded : " << servletName_ << " [class " << sit->second->name() << "]";
			if(_pLogger) _pLogger->error(ss.str());
			throw ExistsException(ss.str());
		}
		else // create new requested class instance servlet
		{
			try
			{
				if(!_servletLoader.isLibraryLoaded(_regServletMap.find(className)->second->libName()))
					loadServletSharedLib(_regServletMap.find(className)->second->libName());
				ContainedFactory<HttpServlet> factory(_servletLoader);
				HttpServlet* pServlet = factory.createInstance(className); 
				poco_check_ptr(pServlet);
				ServletRegInfo* psri = srit->second;
				poco_check_ptr(psri);
				
				const ServletConfigImpl& config = psri->config();
				ServletConfigImpl* pci = new ServletConfigImpl
						  (dynamic_cast<const ServletContextImpl&>(config.getServletContext()));
				poco_check_ptr(pci);				
				pci->setClass(config.getClass());
				pci->setDisplayName(config.getDisplayName());
				pci->setName(servletName_);
				
				std::vector<std::string> params = config.getInitParameterNames();
				std::vector<std::string>::iterator it = params.begin();
				for(; it != params.end(); ++it)
					pci->setInitParameter(*it, config.getInitParameter(*it));

				if(pServlet && pci) pServlet->init(pci);

				ServletRegMap::iterator srmit = _regServletMap.find(className);
				if(srmit == _regServletMap.end())
					throw NotFoundException(className + " not found");

				HttpServletInfo* psi = 
					new HttpServletInfo(servletName_, srmit->second, pServlet);
				poco_check_ptr(psi);
				psi->setSessionId(getSessionId(servletName_));

				_servletMap.insert(make_pair(servletName_, psi));
				ps = psi->instance();
				ss << "Loaded servlet " << servletName_ << " [class " << srit->second->className() << "]";
				if(_pLogger) _pLogger->information(ss.str());
			}
			catch(...)
			{
				ps = 0;
        ss << "Servlet " << servletName_ << " [class " << srit->second->className() << "] failed to load";
				if(_pLogger) _pLogger->error(ss.str());
				throw RuntimeException(ss.str());
			}
		}
	}

	return ps;
}


const Filter* WebApplication::getFilter(const std::string& filterName) const
{
	FilterMap::const_iterator sit = _filterMap.find(filterName);

	if(_filterMap.end() == sit) return 0;

	return  sit->second->instance();
}


const Filter* WebApplication::createFilter(const std::string& className, 
	const std::string& filterName)
{
	Filter* ps = 0;
  if("" == filterName) const_cast<std::string&>(filterName) = className;

	FilterRegMap::iterator srit = _regFilterMap.find(className);

	if(_regFilterMap.end() == srit) // unknown servlet class requested
	{
		std::stringstream ss("");
		ss << "Could not load filter of class [" << className << "]";
		if(_pLogger) _pLogger->error(ss.str());
		throw NotFoundException(ss.str());
	}
	else
	{
		std::stringstream ss("");

		FastMutex::ScopedLock lock(_mutex);

		FilterMap::iterator sit = _filterMap.find(filterName);

		if(_filterMap.end() != sit) // filter already loaded
		{
			ss << "Filter already loaded : " << filterName << " [class " << sit->second->name() << "]";
			if(_pLogger) _pLogger->error(ss.str());
			throw ExistsException(ss.str());
		}
		else // create new requested class instance servlet
		{
			try
			{
				loadFilterSharedLib(_regFilterMap.find(className)->second->libName());
				ContainedFactory<Filter> factory(_filterLoader);
				Filter* pFilter = factory.createInstance(className); 
				poco_check_ptr(pFilter);
				FilterRegInfo* psri = srit->second;
				poco_check_ptr(psri);
				
				const FilterConfigImpl& config = psri->config();
				FilterConfigImpl* pci = new FilterConfigImpl
						  (dynamic_cast<const ServletContextImpl&>(config.getServletContext()));
				poco_check_ptr(pci);				
				pci->setClass(config.getClass());
				pci->setDisplayName(config.getDisplayName());
				pci->setName(filterName);
				
				std::vector<std::string> params = config.getInitParameterNames();
				std::vector<std::string>::iterator it = params.begin();
				for(; it != params.end(); ++it)
					pci->setInitParameter(*it, config.getInitParameter(*it));

				if(pFilter && pci) pFilter->init(pci);

				FilterRegMap::iterator srmit = _regFilterMap.find(className);
				if(srmit == _regFilterMap.end())
					throw NotFoundException(className + " not found");

				FilterInfo* psi = 
					new FilterInfo(filterName, srmit->second, pFilter);
				poco_check_ptr(psi);

				_filterMap.insert(make_pair(filterName, psi));
				ps = psi->instance();
				ss << "Loaded filter " << filterName << " [class " << srit->second->className() << "]";
				if(_pLogger) _pLogger->information(ss.str());
			}
			catch(...)
			{
				ps = 0;
        ss << "Filter " << filterName << " [class " << srit->second->className() << "] failed to load";
				if(_pLogger) _pLogger->error(ss.str());
				throw RuntimeException(ss.str());
			}
		}
	}

	return ps;
}


void WebApplication::setInitParameter(const std::string& name, 
	const std::string& value) 
{ 
	_pContext->setInitParameter(name, value);
}


std::string WebApplication::getInitParameter(const std::string& name) const
{ 
	return getInitParameter(name, "") ;
}


std::string WebApplication::getInitParameter(const std::string& name, 
	const std::string& defValue) const
{ 
	return _pContext->getInitParameter(name, defValue);
}


bool WebApplication::isServletClassRegistered(const std::string& className)
{
	return _regServletMap.end() != _regServletMap.find(className);
}


bool WebApplication::isFilterClassRegistered(const std::string& className)
{
	return _regFilterMap.end() != _regFilterMap.find(className);
}


bool WebApplication::isServletLoaded(const std::string& servletName)
{
	return _servletMap.end() != _servletMap.find(servletName);
}


bool WebApplication::isFilterLoaded(const std::string& filterName)
{
	return _filterMap.end() != _filterMap.find(filterName);
}


std::string WebApplication::getSessionId(const std::string& name)
{
	std::string session("");
	std::string::size_type pos;
	const char ns = ServletProvider::NAME_SEPARATOR;

	if(name.find_first_of(ns) != name.find_last_of(ns))
		throw InvalidArgumentException("Invalid servlet name: " + name);

	if((pos = name.find(ns)) != name.npos)
	{
		session = name.substr(pos+1);
	}

	return session;
}


std::string WebApplication::getServletBaseName(const std::string& name)
{
	std::string session("");
	std::string::size_type pos;
	const char ns = ServletProvider::NAME_SEPARATOR;

	if(name.find_first_of(ns) != name.find_last_of(ns))
		throw InvalidArgumentException("Invalid servlet name: " + name);

	if((pos = name.find(ns)) != name.npos)
	{
		session = name.substr(0, pos);
	}

	return session;
}


std::vector<std::string>& WebApplication::getServletNames(const std::string& id, 
	std::vector<std::string>& servlets)
{
	ServletMap::iterator it = _servletMap.begin();

	for(; it != _servletMap.end(); ++it)
	{
		if(it->second)
		{
			if(id == it->second->getSessionId())
				servlets.push_back(it->second->name());
		}
	}

	return servlets;
}


bool WebApplication::loadServletSharedLib(const std::string& fileName)
{
	std::string dllFile = getSharedLibPath(fileName).toString();

	if(!_servletLoader.isLibraryLoaded(dllFile))
	{
		if(_pLogger)
		{
			std::ostringstream os;
			os << "Loading " << Poco::trim(dllFile);
			_pLogger->information(os.str());
		}

		_servletLoader.loadLibrary(dllFile);
	}

	return _servletLoader.isLibraryLoaded(dllFile);
}


bool WebApplication::loadFilterSharedLib(const std::string& fileName)
{
	std::string dllFile = getSharedLibPath(fileName).toString();

	if(_pLogger)
	{
		std::ostringstream os;
		os << "Loading " << Poco::trim(dllFile);
		_pLogger->information(os.str());
	}

	if(!_filterLoader.isLibraryLoaded(dllFile))
	{
			_filterLoader.loadLibrary(dllFile);
	}

	return _filterLoader.isLibraryLoaded(dllFile);
}


} } } // namespace Poco::Servlet::Container'
